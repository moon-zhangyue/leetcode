<?php
//给定一个正整数 n ，你可以做如下操作： 
//
// 
// 如果 n 是偶数，则用 n / 2替换 n 。 
// 如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。 
// 
//
// n 变为 1 所需的最小替换次数是多少？ 
//
// 
//
// 示例 1： 
//
// 
//输入：n = 8
//输出：3
//解释：8 -> 4 -> 2 -> 1
// 
//
// 示例 2： 
//
// 
//输入：n = 7
//输出：4
//解释：7 -> 8 -> 4 -> 2 -> 1
//或 7 -> 6 -> 3 -> 2 -> 1
// 
//
// 示例 3： 
//
// 
//输入：n = 4
//输出：2
// 
//
// 
//
// 提示： 
//
// 
// 1 <= n <= 2³¹ - 1 
// 
// Related Topics 贪心 位运算 记忆化搜索 动态规划 👍 152 👎 0


//leetcode submit region begin(Prohibit modification and deletion)
class Solution
{

    /**
     * @param Integer $n
     *
     * @return Integer
     */
    function integerReplacement($n)
    {
        //一
        if ($n === 1) {
            return 0;
        }

        if ($n % 2 == 0) {
            return 1 + $this->integerReplacement($n / 2);
        } else {
            return 1 + min($this->integerReplacement($n + 1), $this->integerReplacement($n - 1));
        }

        //二
        /*
         * 当 n 为偶数时，我们只有唯一的方法将 n 替换为 n/2 ；
当 n 为奇数时，n 除以 4 的余数要么为 1，要么为 3。
如果为 1，我们可以断定，应该将 n 变成 (n-1)/2
 。如果我们必须将 n 变成 (n+1)/2才能得到最优解，而 (n+1)/2是奇数，那么：
如果下一步进行 -1 再除以 2，得到 (n-1)/4，那么从(n-1)/2可以除以 2 得到同样的结果；
如果下一步进行 +1 再除以 2，得到 (n+3)/4，那么从(n-1)/2以除以 2 再 +1 得到同样的结果。
因此将 n 变成 (n-1)/2总是不会劣于 (n+1)/2。
如果为 3，我们可以断定，应该将 n 变成 (n+1)/2。如果我们必须将 n 变成 (n-1)/2才能得到最优解，而 (n-1)/2是奇数，那么：
如果下一步进行 -1 再除以 2，得到 (n-3)/4，那么从(n+1)/2可以除以 2 再 -1 得到同样的结果。
如果下一步进行 +1 再除以 2，得到(n+1)/4，那么从 (n+1)/2可以除以 2 得到同样的结果。
因此将 n 变成(n+1)/2总是不会劣于(n-1)/2。但这里还需要考虑一种例外的情况，如果 (n-1)/2已经为 1，即 n=3时，后续就无需再进行任何操作，此时将 n 变成 (n-1)/2才是最优的。
因此，我们只需要根据上面的分类讨论，求出将 n 变为 1 的操作次数即可。
         * */
        $res = 0;

        while ($n !== 1) {
            if ($n % 2 == 0) {
                $n = $n / 2;
            } elseif (($n + 1) % 4 == 0 && $n > 4) {//不能整除就计算 $now + 1 整除2 后的值能不能再次被2 整除(3除外)
                $n = $n + 1;
            } else {
                $n = $n - 1;
            }
            $res++;
        }

        return $res;
    }
}
//leetcode submit region end(Prohibit modification and deletion)
